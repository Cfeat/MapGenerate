<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dåœ°å›¾ç”Ÿæˆå·¥å…· - å®Œæ•´ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0f2e, #1a1a2e, #16213e);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 3.2rem;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            color: #aaa;
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .viewport-container {
            position: relative;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 600px;
            overflow: hidden;
        }
        
        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 5px;
        }
        
        .view-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        .view-controls button {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
        }
        
        .view-controls button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .stats-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }
        
        .stats-overlay div {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .controls {
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
            overflow-y: auto;
        }
        
        .controls h2 {
            color: #00dbde;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #ddd;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #2a3a4a;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fc00ff;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(252, 0, 255, 0.5);
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #00dbde;
        }
        
        .algorithm-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .algorithm-btn {
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .algorithm-btn:hover {
            background-color: rgba(0, 219, 222, 0.2);
            border-color: #00dbde;
        }
        
        .algorithm-btn.active {
            background-color: rgba(0, 219, 222, 0.4);
            border: 1px solid #00dbde;
        }
        
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        
        .preset-btn {
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .preset-btn:hover {
            background-color: rgba(252, 0, 255, 0.2);
            border-color: #fc00ff;
        }
        
        .preset-btn.active {
            background-color: rgba(252, 0, 255, 0.4);
            border: 1px solid #fc00ff;
        }
        
        button {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 219, 222, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .button-group button {
            margin-top: 0;
        }
        
        .toggle-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #fc00ff;
        }
        
        .color-legend {
            display: flex;
            margin-top: 10px;
            height: 20px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .color-legend span {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: #000;
            font-weight: bold;
        }
        
        .info-panel {
            grid-column: 1 / -1;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-panel h3 {
            color: #00dbde;
            margin-bottom: 15px;
        }
        
        .info-panel p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .algo-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 15px;
        }
        
        .algo-info div {
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            border-left: 3px solid #fc00ff;
        }
        
        .algo-info h4 {
            color: #fc00ff;
            margin-bottom: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #888;
            font-size: 0.9rem;
        }
        
        .camera-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }
        
        .instructions {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.85rem;
            color: #aaa;
        }
        
        .terrain-type-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .terrain-type {
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .terrain-type:hover {
            background-color: rgba(0, 219, 222, 0.2);
            border-color: #00dbde;
        }
        
        .terrain-type.active {
            background-color: rgba(0, 219, 222, 0.4);
            border: 1px solid #00dbde;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        
        .loading-text {
            color: #00dbde;
            font-size: 1.2rem;
        }
        
        .resolution-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .resolution-btn {
            flex: 1;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .resolution-btn:hover {
            background-color: rgba(0, 219, 222, 0.2);
            border-color: #00dbde;
        }
        
        .resolution-btn.active {
            background-color: rgba(0, 219, 222, 0.4);
            border: 1px solid #00dbde;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .viewport-container {
                height: 500px;
            }
            
            .algo-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3Dåœ°å›¾ç”Ÿæˆå·¥å…· - å®Œæ•´ç‰ˆ</h1>
            <p class="subtitle">åŸºäºWebGLçš„äº¤äº’å¼3Dåœ°å½¢ç”Ÿæˆå™¨ã€‚æ”¯æŒå¤šç§ç®—æ³•ç”Ÿæˆä¸‰ç»´åœ°å½¢ï¼Œå¯åœ¨3Dç©ºé—´ä¸­æ—‹è½¬ã€ç¼©æ”¾å’Œå¹³ç§»è§†è§’ã€‚</p>
        </header>
        
        <div class="main-content">
            <div class="viewport-container">
                <canvas id="webgl-canvas"></canvas>
                <div class="stats-overlay">
                    <div>é¡¶ç‚¹æ•°: <span id="vertexCount">0</span></div>
                    <div>ä¸‰è§’å½¢æ•°: <span id="triangleCount">0</span></div>
                    <div>æ¸²æŸ“æ—¶é—´: <span id="renderTime">0ms</span></div>
                    <div>FPS: <span id="fpsCounter">0</span></div>
                </div>
                <div class="camera-info">
                    <div>æ‘„åƒæœº: <span id="cameraPosition">(0, 0, 0)</span></div>
                    <div>æ—‹è½¬: <span id="cameraRotation">(0, 0)</span></div>
                </div>
                <div class="view-controls">
                    <button id="resetView" title="é‡ç½®è§†è§’">â†º</button>
                    <button id="topView" title="é¡¶è§†å›¾">â†‘</button>
                    <button id="frontView" title="å‰è§†å›¾">â†’</button>
                    <button id="sideView" title="ä¾§è§†å›¾">â†</button>
                </div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="loading-text">æ­£åœ¨ç”Ÿæˆåœ°å½¢...</div>
                </div>
            </div>
            
            <div class="controls">
                <h2>åœ°å›¾ç”Ÿæˆ</h2>
                <div class="algorithm-selector">
                    <div class="algorithm-btn active" data-algo="perlin">Perlinå™ªå£°</div>
                    <div class="algorithm-btn" data-algo="simplex">Simplexå™ªå£°</div>
                    <div class="algorithm-btn" data-algo="diamond-square">è±å½¢-æ­£æ–¹å½¢</div>
                    <div class="algorithm-btn" data-algo="worley">Worleyå™ªå£°</div>
                </div>
                
                <div class="control-group">
                    <label for="seed">éšæœºç§å­: <span id="seedValue">12345</span></label>
                    <div class="slider-container">
                        <input type="range" id="seed" min="1" max="99999" value="12345" step="1">
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="size">ç½‘æ ¼å¤§å°: <span id="sizeValue">64</span></label>
                    <div class="slider-container">
                        <input type="range" id="size" min="32" max="128" value="64" step="32">
                    </div>
                </div>
                
                <div class="resolution-selector">
                    <div class="resolution-btn active" data-res="low">ä½</div>
                    <div class="resolution-btn" data-res="medium">ä¸­</div>
                    <div class="resolution-btn" data-res="high">é«˜</div>
                </div>
                
                <h2>åœ°å½¢å‚æ•°</h2>
                <div class="terrain-type-selector">
                    <div class="terrain-type active" data-type="hills">ä¸˜é™µ</div>
                    <div class="terrain-type" data-type="mountains">å±±è„‰</div>
                    <div class="terrain-type" data-type="canyons">å³¡è°·</div>
                    <div class="terrain-type" data-type="islands">å²›å±¿</div>
                    <div class="terrain-type" data-type="craters">ç¯å½¢å±±</div>
                    <div class="terrain-type" data-type="waves">æ³¢æµª</div>
                </div>
                
                <div class="control-group">
                    <label for="scale">å™ªå£°ç¼©æ”¾: <span id="scaleValue">0.1</span></label>
                    <div class="slider-container">
                        <input type="range" id="scale" min="0.01" max="0.5" value="0.1" step="0.01">
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="height">é«˜åº¦ç¼©æ”¾: <span id="heightValue">5.0</span></label>
                    <div class="slider-container">
                        <input type="range" id="height" min="0.1" max="20" value="5.0" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="octaves">å€é¢‘ç¨‹: <span id="octavesValue">4</span></label>
                    <div class="slider-container">
                        <input type="range" id="octaves" min="1" max="8" value="4" step="1">
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="persistence">æŒç»­æ€§: <span id="persistenceValue">0.5</span></label>
                    <div class="slider-container">
                        <input type="range" id="persistence" min="0.1" max="1" value="0.5" step="0.05">
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="lacunarity">é¢‘ç‡: <span id="lacunarityValue">2.0</span></label>
                    <div class="slider-container">
                        <input type="range" id="lacunarity" min="1" max="4" value="2.0" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="seaLevel">æµ·å¹³é¢: <span id="seaLevelValue">0.3</span></label>
                    <div class="slider-container">
                        <input type="range" id="seaLevel" min="0" max="1" value="0.3" step="0.01">
                    </div>
                </div>
                
                <h2>æ˜¾ç¤ºé€‰é¡¹</h2>
                <div class="toggle-controls">
                    <div class="checkbox-label">
                        <input type="checkbox" id="wireframe" checked>
                        <label for="wireframe">æ˜¾ç¤ºç½‘æ ¼</label>
                    </div>
                    <div class="checkbox-label">
                        <input type="checkbox" id="smoothShading" checked>
                        <label for="smoothShading">å¹³æ»‘ç€è‰²</label>
                    </div>
                </div>
                
                <div class="toggle-controls">
                    <div class="checkbox-label">
                        <input type="checkbox" id="texture" checked>
                        <label for="texture">æ˜¾ç¤ºçº¹ç†</label>
                    </div>
                    <div class="checkbox-label">
                        <input type="checkbox" id="autoRotate">
                        <label for="autoRotate">è‡ªåŠ¨æ—‹è½¬</label>
                    </div>
                </div>
                
                <div class="color-legend">
                    <span style="background-color: #1a237e;">æ·±æµ·</span>
                    <span style="background-color: #0d47a1;">æµ·æ´‹</span>
                    <span style="background-color: #1976d2;">æµ…æµ·</span>
                    <span style="background-color: #4caf50;">å¹³åŸ</span>
                    <span style="background-color: #8bc34a;">æ£®æ—</span>
                    <span style="background-color: #ff9800;">ä¸˜é™µ</span>
                    <span style="background-color: #795548;">å±±è„‰</span>
                    <span style="background-color: #ffffff;">é›ªå±±</span>
                </div>
                
                <button id="generateBtn">ç”Ÿæˆæ–°åœ°å½¢</button>
                <button id="randomBtn">éšæœºç§å­</button>
                <button id="exportBtn">å¯¼å‡ºOBJ</button>
                <button id="screenshotBtn">æˆªå›¾</button>
                
                <h2 style="margin-top: 20px;">é¢„è®¾</h2>
                <div class="preset-grid">
                    <div class="preset-btn active" data-preset="mountains">å±±è„‰</div>
                    <div class="preset-btn" data-preset="islands">å²›å±¿</div>
                    <div class="preset-btn" data-preset="canyons">å³¡è°·</div>
                    <div class="preset-btn" data-preset="desert">æ²™æ¼ </div>
                    <div class="preset-btn" data-preset="volcano">ç«å±±</div>
                    <div class="preset-btn" data-preset="alien">å¤–æ˜Ÿåœ°å½¢</div>
                </div>
                
                <div class="instructions">
                    <p>ğŸ® ä½¿ç”¨è¯´æ˜ï¼š</p>
                    <p>â€¢ é¼ æ ‡å·¦é”®æ‹–åŠ¨ - æ—‹è½¬è§†è§’</p>
                    <p>â€¢ é¼ æ ‡å³é”®æ‹–åŠ¨ - å¹³ç§»è§†è§’</p>
                    <p>â€¢ é¼ æ ‡æ»šè½® - ç¼©æ”¾</p>
                    <p>â€¢ åŒå‡»åœ°å½¢ - é‡ç½®ç›¸æœºä½ç½®</p>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>3Dåœ°å½¢ç”Ÿæˆç®—æ³•</h3>
            <p>æ­¤å·¥å…·ä½¿ç”¨WebGL 2.0åœ¨æµè§ˆå™¨ä¸­æ¸²æŸ“3Dåœ°å½¢ï¼Œæ”¯æŒå¤šç§å™ªå£°ç®—æ³•å’Œåœ°å½¢å‚æ•°ã€‚</p>
            
            <div class="algo-info">
                <div>
                    <h4>Perlinå™ªå£°</h4>
                    <p>Ken Perlinå¼€å‘çš„ç»å…¸æ¢¯åº¦å™ªå£°ç®—æ³•ï¼Œç”Ÿæˆå¹³æ»‘ã€è‡ªç„¶çš„éšæœºåœ°å½¢ã€‚é€šè¿‡å åŠ å¤šä¸ªå€é¢‘ç¨‹å®ç°åˆ†å½¢æ•ˆæœã€‚</p>
                </div>
                <div>
                    <h4>Simplexå™ªå£°</h4>
                    <p>Perlinå™ªå£°çš„æ”¹è¿›ç‰ˆï¼Œè®¡ç®—æ•ˆç‡æ›´é«˜ï¼Œå°¤å…¶åœ¨é«˜ç»´åº¦ä¸Šï¼Œç”Ÿæˆæ›´è‡ªç„¶çš„è§†è§‰æ•ˆæœã€‚</p>
                </div>
                <div>
                    <h4>è±å½¢-æ­£æ–¹å½¢</h4>
                    <p>ç»å…¸çš„åˆ†å½¢åœ°å½¢ç”Ÿæˆç®—æ³•ï¼Œä»ç½‘æ ¼çš„å››ä¸ªè§’å¼€å§‹ï¼Œé€’å½’è®¡ç®—ä¸­ç‚¹å’Œè¾¹ç‚¹é«˜åº¦ã€‚</p>
                </div>
                <div>
                    <h4>Worleyå™ªå£°</h4>
                    <p>ç»†èƒå™ªå£°ç®—æ³•ï¼Œç”Ÿæˆç±»ä¼¼ç»†èƒã€çŸ³å—æˆ–ç”Ÿç‰©ç»„ç»‡çš„å›¾æ¡ˆï¼Œé€‚åˆç”Ÿæˆç‰¹æ®Šåœ°å½¢ã€‚</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>3Dåœ°å›¾ç”Ÿæˆå·¥å…· - å®Œæ•´ç‰ˆ &copy; 2023 | ä½¿ç”¨WebGL 2.0å’ŒJavaScriptå®ç° | åŸºäºå¤šç§å™ªå£°ç®—æ³•</p>
        </footer>
    </div>
    
    <script>
        // å…¨å±€å˜é‡
        let canvas, gl;
        let terrain = { buffers: null, vertices: [], indices: [] };
        let camera = { x: 0, y: 8, z: 15, rx: -0.5, ry: 0 };
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let dragType = 'rotate';
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;
        let terrainShader = null;
        
        // è·å–DOMå…ƒç´ 
        const seedSlider = document.getElementById('seed');
        const sizeSlider = document.getElementById('size');
        const scaleSlider = document.getElementById('scale');
        const heightSlider = document.getElementById('height');
        const octavesSlider = document.getElementById('octaves');
        const persistenceSlider = document.getElementById('persistence');
        const lacunaritySlider = document.getElementById('lacunarity');
        const seaLevelSlider = document.getElementById('seaLevel');
        
        const seedValue = document.getElementById('seedValue');
        const sizeValue = document.getElementById('sizeValue');
        const scaleValue = document.getElementById('scaleValue');
        const heightValue = document.getElementById('heightValue');
        const octavesValue = document.getElementById('octavesValue');
        const persistenceValue = document.getElementById('persistenceValue');
        const lacunarityValue = document.getElementById('lacunarityValue');
        const seaLevelValue = document.getElementById('seaLevelValue');
        
        const vertexCountSpan = document.getElementById('vertexCount');
        const triangleCountSpan = document.getElementById('triangleCount');
        const renderTimeSpan = document.getElementById('renderTime');
        const fpsCounter = document.getElementById('fpsCounter');
        const cameraPositionSpan = document.getElementById('cameraPosition');
        const cameraRotationSpan = document.getElementById('cameraRotation');
        
        const generateBtn = document.getElementById('generateBtn');
        const randomBtn = document.getElementById('randomBtn');
        const exportBtn = document.getElementById('exportBtn');
        const screenshotBtn = document.getElementById('screenshotBtn');
        const resetViewBtn = document.getElementById('resetView');
        const topViewBtn = document.getElementById('topView');
        const frontViewBtn = document.getElementById('frontView');
        const sideViewBtn = document.getElementById('sideView');
        
        const algorithmBtns = document.querySelectorAll('.algorithm-btn');
        const resolutionBtns = document.querySelectorAll('.resolution-btn');
        const terrainTypeBtns = document.querySelectorAll('.terrain-type');
        const presetBtns = document.querySelectorAll('.preset-btn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        
        const wireframeCheckbox = document.getElementById('wireframe');
        const smoothShadingCheckbox = document.getElementById('smoothShading');
        const textureCheckbox = document.getElementById('texture');
        const autoRotateCheckbox = document.getElementById('autoRotate');
        
        // å½“å‰ç®—æ³•
        let currentAlgorithm = 'perlin';
        let currentResolution = 'medium';
        let currentTerrainType = 'hills';
        let currentWireframe = true;
        let currentSmoothShading = true;
        let currentTexture = true;
        let currentAutoRotate = false;
        
        // åˆ†è¾¨ç‡è®¾ç½®
        const RESOLUTION = {
            low: 32,
            medium: 64,
            high: 128
        };
        
        // åœ°å½¢é¢„è®¾
        const TERRAIN_PRESETS = {
            mountains: { scale: 0.08, height: 15.0, octaves: 6, persistence: 0.4, lacunarity: 2.2, seaLevel: 0.3 },
            islands: { scale: 0.12, height: 8.0, octaves: 5, persistence: 0.5, lacunarity: 2.0, seaLevel: 0.4 },
            canyons: { scale: 0.05, height: 12.0, octaves: 4, persistence: 0.6, lacunarity: 1.8, seaLevel: 0.2 },
            desert: { scale: 0.15, height: 3.0, octaves: 3, persistence: 0.3, lacunarity: 2.5, seaLevel: 0.1 },
            volcano: { scale: 0.06, height: 20.0, octaves: 7, persistence: 0.5, lacunarity: 2.0, seaLevel: 0.3 },
            alien: { scale: 0.2, height: 10.0, octaves: 8, persistence: 0.7, lacunarity: 2.8, seaLevel: 0.5 }
        };
        
        // åœ°å½¢ç±»å‹å‚æ•°
        const TERRAIN_TYPES = {
            hills: { scale: 0.1, height: 5.0, octaves: 4, persistence: 0.5, lacunarity: 2.0 },
            mountains: { scale: 0.08, height: 15.0, octaves: 6, persistence: 0.4, lacunarity: 2.2 },
            canyons: { scale: 0.05, height: 12.0, octaves: 4, persistence: 0.6, lacunarity: 1.8 },
            islands: { scale: 0.12, height: 8.0, octaves: 5, persistence: 0.5, lacunarity: 2.0 },
            craters: { scale: 0.2, height: 8.0, octaves: 3, persistence: 0.8, lacunarity: 2.5 },
            waves: { scale: 0.3, height: 3.0, octaves: 2, persistence: 0.5, lacunarity: 2.0 }
        };
        
        // é¢œè‰²æ–¹æ¡ˆ
        const COLORS = [
            {value: 0.0, color: {r: 26/255, g: 35/255, b: 126/255}},
            {value: 0.2, color: {r: 13/255, g: 71/255, b: 161/255}},
            {value: 0.3, color: {r: 25/255, g: 118/255, b: 210/255}},
            {value: 0.4, color: {r: 76/255, g: 175/255, b: 80/255}},
            {value: 0.6, color: {r: 139/255, g: 195/255, b: 74/255}},
            {value: 0.75, color: {r: 255/255, g: 152/255, b: 0/255}},
            {value: 0.85, color: {r: 121/255, g: 85/255, b: 72/255}},
            {value: 1.0, color: {r: 1.0, g: 1.0, b: 1.0}}
        ];
        
        // åˆå§‹åŒ–WebGL
        function initWebGL() {
            canvas = document.getElementById('webgl-canvas');
            
            // å°è¯•è·å–WebGLä¸Šä¸‹æ–‡
            gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGLã€‚è¯·ä½¿ç”¨Chromeã€Firefoxæˆ–Edgeç­‰ç°ä»£æµè§ˆå™¨ã€‚');
                return;
            }
            
            console.log('WebGLä¸Šä¸‹æ–‡åˆ›å»ºæˆåŠŸ:', gl.getParameter(gl.VERSION));
            
            // è®¾ç½®Canvaså¤§å°
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // è®¾ç½®WebGLå±æ€§
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);
            gl.clearColor(0.1, 0.1, 0.2, 1.0);
            
            // åŠ è½½ç€è‰²å™¨
            const vsSource = `
                attribute vec3 aPosition;
                attribute vec3 aColor;
                attribute vec3 aNormal;
                
                varying vec3 vColor;
                varying vec3 vNormal;
                varying vec3 vFragPos;
                
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                uniform mat3 uNormalMatrix;
                
                void main() {
                    vec4 worldPosition = uModelViewMatrix * vec4(aPosition, 1.0);
                    vFragPos = worldPosition.xyz;
                    vColor = aColor;
                    vNormal = uNormalMatrix * aNormal;
                    gl_Position = uProjectionMatrix * worldPosition;
                }
            `;
            
            const fsSource = `
                precision mediump float;
                
                varying vec3 vColor;
                varying vec3 vNormal;
                varying vec3 vFragPos;
                
                uniform vec3 uLightColor;
                uniform vec3 uLightPosition;
                uniform vec3 uViewPosition;
                
                void main() {
                    // ç¯å¢ƒå…‰
                    float ambientStrength = 0.3;
                    vec3 ambient = ambientStrength * uLightColor;
                    
                    // æ¼«åå°„
                    vec3 lightDir = normalize(uLightPosition - vFragPos);
                    vec3 normal = normalize(vNormal);
                    float diff = max(dot(normal, lightDir), 0.0);
                    vec3 diffuse = diff * uLightColor;
                    
                    // é•œé¢åå°„
                    float specularStrength = 0.5;
                    vec3 viewDir = normalize(uViewPosition - vFragPos);
                    vec3 reflectDir = reflect(-lightDir, normal);
                    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                    vec3 specular = specularStrength * spec * uLightColor;
                    
                    vec3 result = (ambient + diffuse + specular) * vColor;
                    gl_FragColor = vec4(result, 1.0);
                }
            `;
            
            // ç¼–è¯‘ç€è‰²å™¨
            terrainShader = compileShaderProgram(vsSource, fsSource);
            
            if (!terrainShader) {
                alert('ç€è‰²å™¨ç¼–è¯‘å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°é”™è¯¯ä¿¡æ¯');
                return;
            }
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            // ç”Ÿæˆåˆå§‹åœ°å½¢
            generateTerrain();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        // ç¼–è¯‘ç€è‰²å™¨ç¨‹åº
        function compileShaderProgram(vsSource, fsSource) {
            const vs = gl.createShader(gl.VERTEX_SHADER);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            
            gl.shaderSource(vs, vsSource);
            gl.shaderSource(fs, fsSource);
            
            gl.compileShader(vs);
            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                console.error('é¡¶ç‚¹ç€è‰²å™¨ç¼–è¯‘é”™è¯¯:', gl.getShaderInfoLog(vs));
                return null;
            }
            
            gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                console.error('ç‰‡æ®µç€è‰²å™¨ç¼–è¯‘é”™è¯¯:', gl.getShaderInfoLog(fs));
                return null;
            }
            
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ç€è‰²å™¨ç¨‹åºé“¾æ¥é”™è¯¯:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return {
                program: program,
                attributes: {
                    position: gl.getAttribLocation(program, 'aPosition'),
                    color: gl.getAttribLocation(program, 'aColor'),
                    normal: gl.getAttribLocation(program, 'aNormal')
                },
                uniforms: {
                    modelViewMatrix: gl.getUniformLocation(program, 'uModelViewMatrix'),
                    projectionMatrix: gl.getUniformLocation(program, 'uProjectionMatrix'),
                    normalMatrix: gl.getUniformLocation(program, 'uNormalMatrix'),
                    lightPosition: gl.getUniformLocation(program, 'uLightPosition'),
                    lightColor: gl.getUniformLocation(program, 'uLightColor'),
                    viewPosition: gl.getUniformLocation(program, 'uViewPosition')
                }
            };
        }
        
        // è°ƒæ•´Canvaså¤§å°
        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, width, height);
            }
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // é¼ æ ‡æ§åˆ¶
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                dragType = e.button === 0 ? 'rotate' : 'pan';
                canvas.style.cursor = dragType === 'rotate' ? 'grabbing' : 'move';
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                
                if (dragType === 'rotate') {
                    camera.ry += dx * 0.01;
                    camera.rx += dy * 0.01;
                    camera.rx = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rx));
                } else {
                    camera.x += dx * 0.01;
                    camera.y -= dy * 0.01;
                }
                
                lastX = e.clientX;
                lastY = e.clientY;
            });
            
            // é¼ æ ‡æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.z *= 1 + e.deltaY * 0.001;
                camera.z = Math.max(2, Math.min(50, camera.z));
            });
            
            // åŒå‡»é‡ç½®ç›¸æœº
            canvas.addEventListener('dblclick', (e) => {
                e.preventDefault();
                resetCamera();
            });
            
            // æ§ä»¶äº‹ä»¶
            seedSlider.addEventListener('input', () => {
                seedValue.textContent = seedSlider.value;
            });
            
            sizeSlider.addEventListener('input', () => {
                sizeValue.textContent = sizeSlider.value;
            });
            
            scaleSlider.addEventListener('input', () => {
                scaleValue.textContent = parseFloat(scaleSlider.value).toFixed(2);
            });
            
            heightSlider.addEventListener('input', () => {
                heightValue.textContent = parseFloat(heightSlider.value).toFixed(1);
            });
            
            octavesSlider.addEventListener('input', () => {
                octavesValue.textContent = octavesSlider.value;
            });
            
            persistenceSlider.addEventListener('input', () => {
                persistenceValue.textContent = parseFloat(persistenceSlider.value).toFixed(2);
            });
            
            lacunaritySlider.addEventListener('input', () => {
                lacunarityValue.textContent = parseFloat(lacunaritySlider.value).toFixed(1);
            });
            
            seaLevelSlider.addEventListener('input', () => {
                seaLevelValue.textContent = parseFloat(seaLevelSlider.value).toFixed(2);
            });
            
            // ç”ŸæˆæŒ‰é’®
            generateBtn.addEventListener('click', () => {
                generateTerrain();
            });
            
            randomBtn.addEventListener('click', () => {
                const randomSeed = Math.floor(Math.random() * 99999) + 1;
                seedSlider.value = randomSeed;
                seedValue.textContent = randomSeed;
                generateTerrain();
            });
            
            // å¯¼å‡ºæŒ‰é’®
            exportBtn.addEventListener('click', exportOBJ);
            screenshotBtn.addEventListener('click', takeScreenshot);
            
            // è§†è§’æŒ‰é’®
            resetViewBtn.addEventListener('click', resetCamera);
            topViewBtn.addEventListener('click', () => setCameraView('top'));
            frontViewBtn.addEventListener('click', () => setCameraView('front'));
            sideViewBtn.addEventListener('click', () => setCameraView('side'));
            
            // ç®—æ³•é€‰æ‹©
            algorithmBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    algorithmBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentAlgorithm = btn.getAttribute('data-algo');
                    generateTerrain();
                });
            });
            
            // åˆ†è¾¨ç‡é€‰æ‹©
            resolutionBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    resolutionBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentResolution = btn.getAttribute('data-res');
                    const size = RESOLUTION[currentResolution];
                    sizeSlider.value = size;
                    sizeValue.textContent = size;
                    generateTerrain();
                });
            });
            
            // åœ°å½¢ç±»å‹é€‰æ‹©
            terrainTypeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    terrainTypeBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTerrainType = btn.getAttribute('data-type');
                    
                    const type = TERRAIN_TYPES[currentTerrainType];
                    scaleSlider.value = type.scale;
                    heightSlider.value = type.height;
                    octavesSlider.value = type.octaves;
                    persistenceSlider.value = type.persistence;
                    lacunaritySlider.value = type.lacunarity;
                    
                    scaleValue.textContent = type.scale.toFixed(2);
                    heightValue.textContent = type.height.toFixed(1);
                    octavesValue.textContent = type.octaves;
                    persistenceValue.textContent = type.persistence.toFixed(2);
                    lacunarityValue.textContent = type.lacunarity.toFixed(1);
                    
                    generateTerrain();
                });
            });
            
            // é¢„è®¾
            presetBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    presetBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const preset = btn.getAttribute('data-preset');
                    applyPreset(preset);
                });
            });
            
            // å¤é€‰æ¡†
            wireframeCheckbox.addEventListener('change', () => {
                currentWireframe = wireframeCheckbox.checked;
            });
            
            smoothShadingCheckbox.addEventListener('change', () => {
                currentSmoothShading = smoothShadingCheckbox.checked;
                generateTerrain();
            });
            
            textureCheckbox.addEventListener('change', () => {
                currentTexture = textureCheckbox.checked;
            });
            
            autoRotateCheckbox.addEventListener('change', () => {
                currentAutoRotate = autoRotateCheckbox.checked;
            });
        }
        
        // åº”ç”¨é¢„è®¾
        function applyPreset(presetName) {
            const preset = TERRAIN_PRESETS[presetName];
            if (!preset) return;
            
            scaleSlider.value = preset.scale;
            heightSlider.value = preset.height;
            octavesSlider.value = preset.octaves;
            persistenceSlider.value = preset.persistence;
            lacunaritySlider.value = preset.lacunarity;
            seaLevelSlider.value = preset.seaLevel;
            
            scaleValue.textContent = preset.scale.toFixed(2);
            heightValue.textContent = preset.height.toFixed(1);
            octavesValue.textContent = preset.octaves;
            persistenceValue.textContent = preset.persistence.toFixed(2);
            lacunarityValue.textContent = preset.lacunarity.toFixed(1);
            seaLevelValue.textContent = preset.seaLevel.toFixed(2);
            
            generateTerrain();
        }
        
        // ç”Ÿæˆåœ°å½¢
        function generateTerrain() {
            loadingOverlay.style.display = 'flex';
            
            setTimeout(() => {
                try {
                    const startTime = performance.now();
                    
                    const seed = parseInt(seedSlider.value);
                    const size = parseInt(sizeSlider.value);
                    const scale = parseFloat(scaleSlider.value);
                    const height = parseFloat(heightSlider.value);
                    const octaves = parseInt(octavesSlider.value);
                    const persistence = parseFloat(persistenceSlider.value);
                    const lacunarity = parseFloat(lacunaritySlider.value);
                    const seaLevel = parseFloat(seaLevelSlider.value);
                    
                    const algorithm = currentAlgorithm;
                    
                    // åˆ›å»ºåœ°å½¢ç½‘æ ¼
                    const gridSize = size;
                    const terrainData = createTerrain(gridSize, seed, scale, height, octaves, 
                        persistence, lacunarity, seaLevel, algorithm);
                    
                    // ä¸ºWebGLå‡†å¤‡åœ°å½¢
                    prepareTerrainForWebGL(terrainData);
                    
                    const endTime = performance.now();
                    renderTimeSpan.textContent = Math.round(endTime - startTime) + 'ms';
                    
                    // æ›´æ–°ç»Ÿè®¡
                    const vertices = terrainData.vertices.length / 3;
                    const triangles = terrainData.indices.length / 3;
                    vertexCountSpan.textContent = vertices.toLocaleString();
                    triangleCountSpan.textContent = triangles.toLocaleString();
                    
                } catch (error) {
                    console.error('ç”Ÿæˆåœ°å½¢æ—¶å‡ºé”™:', error);
                    alert('ç”Ÿæˆåœ°å½¢æ—¶å‡ºé”™: ' + error.message);
                } finally {
                    loadingOverlay.style.display = 'none';
                }
            }, 50);
        }
        
        // åˆ›å»ºåœ°å½¢
        function createTerrain(size, seed, scale, heightMultiplier, octaves, persistence, lacunarity, seaLevel, algorithm) {
            console.log(`ç”Ÿæˆåœ°å½¢: size=${size}, scale=${scale}, height=${heightMultiplier}, algorithm=${algorithm}`);
            
            const terrain = {
                vertices: [],
                normals: [],
                colors: [],
                indices: []
            };
            
            const halfSize = (size - 1) / 2;
            const vertices = [];
            
            // ç”Ÿæˆé«˜åº¦å›¾
            const heightMap = generateHeightMap(size, seed, scale, octaves, persistence, lacunarity, algorithm);
            
            // åˆ›å»ºé¡¶ç‚¹
            for (let z = 0; z < size; z++) {
                for (let x = 0; x < size; x++) {
                    const h = heightMap[z][x];
                    
                    // é¡¶ç‚¹ä½ç½®
                    const px = (x - halfSize) * 1.0;
                    const pz = (z - halfSize) * 1.0;
                    const py = h * heightMultiplier;
                    
                    vertices.push(px, py, pz);
                    
                    // é¡¶ç‚¹é¢œè‰²
                    const normalizedHeight = (py + heightMultiplier) / (heightMultiplier * 2);
                    const color = getColorByHeight(normalizedHeight, seaLevel);
                    terrain.colors.push(color.r, color.g, color.b);
                }
            }
            
            terrain.vertices = vertices;
            
            // åˆ›å»ºç´¢å¼•
            for (let z = 0; z < size - 1; z++) {
                for (let x = 0; x < size - 1; x++) {
                    const topLeft = z * size + x;
                    const topRight = z * size + (x + 1);
                    const bottomLeft = (z + 1) * size + x;
                    const bottomRight = (z + 1) * size + (x + 1);
                    
                    terrain.indices.push(topLeft, bottomLeft, topRight);
                    terrain.indices.push(topRight, bottomLeft, bottomRight);
                }
            }
            
            // è®¡ç®—æ³•çº¿
            calculateNormals(terrain);
            
            return terrain;
        }
        
        // ç”Ÿæˆé«˜åº¦å›¾
        function generateHeightMap(size, seed, scale, octaves, persistence, lacunarity, algorithm) {
            console.log(`ç”Ÿæˆé«˜åº¦å›¾: ${algorithm}, size=${size}`);
            const heightMap = Array(size).fill().map(() => Array(size).fill(0));
            const random = new SeededRandom(seed);
            
            switch(algorithm) {
                case 'perlin':
                    return generatePerlinNoise(size, scale, octaves, persistence, lacunarity, random);
                case 'simplex':
                    return generateSimplexNoise(size, scale, octaves, persistence, lacunarity, random);
                case 'diamond-square':
                    return generateDiamondSquare(size, random);
                case 'worley':
                    return generateWorleyNoise(size, scale, random);
                default:
                    return generatePerlinNoise(size, scale, octaves, persistence, lacunarity, random);
            }
        }
        
        // æŸæ—å™ªå£°ç”Ÿæˆ
        function generatePerlinNoise(size, scale, octaves, persistence, lacunarity, random) {
            const heightMap = Array(size).fill().map(() => Array(size).fill(0));
            const perlin = new PerlinNoise(random);
            
            for (let octave = 0; octave < octaves; octave++) {
                const frequency = Math.pow(lacunarity, octave);
                const amplitude = Math.pow(persistence, octave);
                
                for (let z = 0; z < size; z++) {
                    for (let x = 0; x < size; x++) {
                        const sampleX = x * scale * frequency / size;
                        const sampleZ = z * scale * frequency / size;
                        const noiseValue = perlin.noise(sampleX, sampleZ, 0);
                        
                        heightMap[z][x] += noiseValue * amplitude;
                    }
                }
            }
            
            return normalizeHeightMap(heightMap, size);
        }
        
        // Simplexå™ªå£°ç”Ÿæˆ
        function generateSimplexNoise(size, scale, octaves, persistence, lacunarity, random) {
            const heightMap = Array(size).fill().map(() => Array(size).fill(0));
            const simplex = new SimplexNoise(random);
            
            for (let octave = 0; octave < octaves; octave++) {
                const frequency = Math.pow(lacunarity, octave);
                const amplitude = Math.pow(persistence, octave);
                
                for (let z = 0; z < size; z++) {
                    for (let x = 0; x < size; x++) {
                        const sampleX = x * scale * frequency / size;
                        const sampleZ = z * scale * frequency / size;
                        const noiseValue = simplex.noise(sampleX, sampleZ, 0);
                        
                        heightMap[z][x] += noiseValue * amplitude;
                    }
                }
            }
            
            return normalizeHeightMap(heightMap, size);
        }
        
        // è±å½¢-æ­£æ–¹å½¢ç®—æ³•
        function generateDiamondSquare(size, random) {
            const heightMap = Array(size).fill().map(() => Array(size).fill(0));
            
            // åˆå§‹åŒ–å››ä¸ªè§’
            heightMap[0][0] = random.random() * 2 - 1;
            heightMap[0][size-1] = random.random() * 2 - 1;
            heightMap[size-1][0] = random.random() * 2 - 1;
            heightMap[size-1][size-1] = random.random() * 2 - 1;
            
            let step = size - 1;
            let roughness = 1.0;
            
            while (step > 1) {
                const halfStep = Math.floor(step / 2);
                
                // è±å½¢æ­¥éª¤
                for (let y = halfStep; y < size; y += step) {
                    for (let x = halfStep; x < size; x += step) {
                        const avg = (
                            heightMap[y-halfStep][x-halfStep] +
                            heightMap[y-halfStep][x+halfStep] +
                            heightMap[y+halfStep][x-halfStep] +
                            heightMap[y+halfStep][x+halfStep]
                        ) / 4;
                        heightMap[y][x] = avg + (random.random() * 2 - 1) * roughness;
                    }
                }
                
                // æ­£æ–¹å½¢æ­¥éª¤
                for (let y = 0; y < size; y += halfStep) {
                    for (let x = (y + halfStep) % step; x < size; x += step) {
                        let sum = 0;
                        let count = 0;
                        
                        if (x - halfStep >= 0) { sum += heightMap[y][x - halfStep]; count++; }
                        if (x + halfStep < size) { sum += heightMap[y][x + halfStep]; count++; }
                        if (y - halfStep >= 0) { sum += heightMap[y - halfStep][x]; count++; }
                        if (y + halfStep < size) { sum += heightMap[y + halfStep][x]; count++; }
                        
                        heightMap[y][x] = (sum / count) + (random.random() * 2 - 1) * roughness;
                    }
                }
                
                step = halfStep;
                roughness *= 0.5;
            }
            
            return normalizeHeightMap(heightMap, size);
        }
        
        // Worleyå™ªå£°
        function generateWorleyNoise(size, scale, random) {
            const heightMap = Array(size).fill().map(() => Array(size).fill(0));
            
            // åˆ›å»ºç‰¹å¾ç‚¹
            const featureCount = Math.max(10, Math.floor(size * scale));
            const features = [];
            
            for (let i = 0; i < featureCount; i++) {
                features.push({
                    x: random.random() * size,
                    y: random.random() * size,
                    radius: random.random() * 0.5 + 0.5
                });
            }
            
            // è®¡ç®—Worleyå™ªå£°
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    let minDist = Infinity;
                    
                    for (const feature of features) {
                        const dx = (x / size) - (feature.x / size);
                        const dy = (y / size) - (feature.y / size);
                        const distance = Math.sqrt(dx * dx + dy * dy) / feature.radius;
                        
                        if (distance < minDist) {
                            minDist = distance;
                        }
                    }
                    
                    heightMap[y][x] = Math.min(minDist, 1.0) * 2 - 1;
                }
            }
            
            return normalizeHeightMap(heightMap, size);
        }
        
        // å½’ä¸€åŒ–é«˜åº¦å›¾
        function normalizeHeightMap(heightMap, size) {
            let min = Infinity;
            let max = -Infinity;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    min = Math.min(min, heightMap[y][x]);
                    max = Math.max(max, heightMap[y][x]);
                }
            }
            
            const range = max - min;
            if (range === 0) return heightMap;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    heightMap[y][x] = (heightMap[y][x] - min) / range;
                }
            }
            
            return heightMap;
        }
        
        // è®¡ç®—æ³•çº¿
        function calculateNormals(terrainData) {
            const vertices = terrainData.vertices;
            const size = Math.sqrt(terrainData.vertices.length / 3);
            const normals = new Array(vertices.length).fill(0);
            
            for (let z = 0; z < size - 1; z++) {
                for (let x = 0; x < size - 1; x++) {
                    const v1 = z * size + x;
                    const v2 = (z + 1) * size + x;
                    const v3 = z * size + (x + 1);
                    const v4 = (z + 1) * size + (x + 1);
                    
                    const p1 = {x: vertices[v1 * 3], y: vertices[v1 * 3+1], z: vertices[v1 * 3+2]};
                    const p2 = {x: vertices[v2 * 3], y: vertices[v2 * 3+1], z: vertices[v2 * 3+2]};
                    const p3 = {x: vertices[v3 * 3], y: vertices[v3 * 3+1], z: vertices[v3 * 3+2]};
                    const p4 = {x: vertices[v4 * 3], y: vertices[v4 * 3+1], z: vertices[v4 * 3+2]};
                    
                    // è®¡ç®—æ¯ä¸ªé¢çš„æ³•çº¿
                    const n1 = computeNormal(p1, p2, p3);
                    const n2 = computeNormal(p3, p2, p4);
                    
                    addNormal(normals, v1, n1);
                    addNormal(normals, v2, n1);
                    addNormal(normals, v3, n1);
                    
                    addNormal(normals, v3, n2);
                    addNormal(normals, v2, n2);
                    addNormal(normals, v4, n2);
                }
            }
            
            // å½’ä¸€åŒ–æ³•çº¿
            for (let i = 0; i < normals.length; i += 3) {
                const nx = normals[i];
                const ny = normals[i+1];
                const nz = normals[i+2];
                const length = Math.sqrt(nx*nx + ny*ny + nz*nz);
                
                if (length > 0) {
                    normals[i] = nx / length;
                    normals[i+1] = ny / length;
                    normals[i+2] = nz / length;
                }
            }
            
            terrainData.normals = normals;
        }
        
        function computeNormal(p1, p2, p3) {
            const v1 = {x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z};
            const v2 = {x: p3.x - p1.x, y: p3.y - p1.y, z: p3.z - p1.z};
            
            const nx = v1.y * v2.z - v1.z * v2.y;
            const ny = v1.z * v2.x - v1.x * v2.z;
            const nz = v1.x * v2.y - v1.y * v2.x;
            
            const length = Math.sqrt(nx * nx + ny * ny + nz * nz);
            
            return {
                x: length > 0 ? nx / length : 0,
                y: length > 0 ? ny / length : 1,
                z: length > 0 ? nz / length : 0
            };
        }
        
        function addNormal(normals, vertexIndex, normal) {
            const idx = vertexIndex * 3;
            normals[idx] += normal.x;
            normals[idx + 1] += normal.y;
            normals[idx + 2] += normal.z;
        }
        
        // å‡†å¤‡åœ°å½¢æ•°æ®
        function prepareTerrainForWebGL(terrainData) {
            if (!terrainShader) {
                console.error('ç€è‰²å™¨æœªåˆå§‹åŒ–');
                return;
            }
            
            // æ¸…ç†æ—§çš„ç¼“å†²åŒº
            if (terrain.buffers) {
                if (terrain.buffers.vertexBuffer) gl.deleteBuffer(terrain.buffers.vertexBuffer);
                if (terrain.buffers.normalBuffer) gl.deleteBuffer(terrain.buffers.normalBuffer);
                if (terrain.buffers.colorBuffer) gl.deleteBuffer(terrain.buffers.colorBuffer);
                if (terrain.buffers.indexBuffer) gl.deleteBuffer(terrain.buffers.indexBuffer);
            }
            
            // åˆ›å»ºæ–°çš„ç¼“å†²åŒº
            const vertexBuffer = gl.createBuffer();
            const normalBuffer = gl.createBuffer();
            const colorBuffer = gl.createBuffer();
            const indexBuffer = gl.createBuffer();
            
            // è®¾ç½®é¡¶ç‚¹æ•°æ®
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainData.vertices), gl.STATIC_DRAW);
            
            // è®¾ç½®æ³•çº¿æ•°æ®
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainData.normals), gl.STATIC_DRAW);
            
            // è®¾ç½®é¢œè‰²æ•°æ®
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainData.colors), gl.STATIC_DRAW);
            
            // è®¾ç½®ç´¢å¼•æ•°æ®
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(terrainData.indices), gl.STATIC_DRAW);
            
            terrain.vertices = terrainData.vertices;
            terrain.normals = terrainData.normals;
            terrain.colors = terrainData.colors;
            terrain.indices = terrainData.indices;
            terrain.buffers = {
                vertexBuffer,
                normalBuffer,
                colorBuffer,
                indexBuffer,
                indexCount: terrainData.indices.length
            };
            
            console.log(`åœ°å½¢æ•°æ®å‡†å¤‡å®Œæˆ: ${terrainData.vertices.length/3} é¡¶ç‚¹, ${terrainData.indices.length/3} ä¸‰è§’å½¢`);
        }
        
        // è·å–é¢œè‰²
        function getColorByHeight(height, seaLevel) {
            // åº”ç”¨æµ·å¹³é¢
            if (height < seaLevel) {
                height = height / seaLevel * 0.3;
            } else {
                height = 0.3 + (height - seaLevel) / (1 - seaLevel) * 0.7;
            }
            
            for (let i = 0; i < COLORS.length; i++) {
                if (height <= COLORS[i].value || i === COLORS.length - 1) {
                    return COLORS[i].color;
                }
            }
            return COLORS[COLORS.length - 1].color;
        }
        
        // å¯¼å‡ºä¸ºOBJ
        function exportOBJ() {
            if (!terrain || !terrain.vertices) {
                alert('æ²¡æœ‰åœ°å½¢æ•°æ®å¯å¯¼å‡º');
                return;
            }
            
            let objContent = "# 3Dåœ°å½¢æ•°æ®\n";
            objContent += "# ç”Ÿæˆäº3Dåœ°å½¢ç”Ÿæˆå™¨\n\n";
            
            // é¡¶ç‚¹
            for (let i = 0; i < terrain.vertices.length; i += 3) {
                objContent += `v ${terrain.vertices[i].toFixed(4)} ${terrain.vertices[i+1].toFixed(4)} ${terrain.vertices[i+2].toFixed(4)}\n`;
            }
            
            // é¢
            objContent += "\n# é¢\n";
            for (let i = 0; i < terrain.indices.length; i += 3) {
                const v1 = terrain.indices[i] + 1;
                const v2 = terrain.indices[i+1] + 1;
                const v3 = terrain.indices[i+2] + 1;
                objContent += `f ${v1} ${v2} ${v3}\n`;
            }
            
            const blob = new Blob([objContent], {type: 'text/plain'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `terrain-${Date.now()}.obj`;
            link.click();
        }
        
        // æˆªå›¾
        function takeScreenshot() {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `terrain-3d-${Date.now()}.png`;
            link.click();
        }
        
        // é‡ç½®ç›¸æœº
        function resetCamera() {
            camera = { x: 0, y: 8, z: 15, rx: -0.5, ry: 0 };
        }
        
        // è®¾ç½®ç›¸æœºè§†è§’
        function setCameraView(view) {
            switch(view) {
                case 'top':
                    camera = { x: 0, y: 20, z: 0.1, rx: -Math.PI/2, ry: 0 };
                    break;
                case 'front':
                    camera = { x: 0, y: 5, z: 20, rx: 0, ry: 0 };
                    break;
                case 'side':
                    camera = { x: 20, y: 5, z: 0, rx: 0, ry: Math.PI/2 };
                    break;
            }
        }
        
        // æ¸²æŸ“å‡½æ•°
        function render() {
            if (!gl || !terrainShader || !terrain.buffers) {
                return;
            }
            
            const width = canvas.width;
            const height = canvas.height;
            
            // æ¸…å±
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // å¯ç”¨ç€è‰²å™¨
            gl.useProgram(terrainShader.program);
            
            // è®¡ç®—æŠ•å½±çŸ©é˜µ
            const projectionMatrix = mat4.create();
            const aspect = width / height;
            mat4.perspective(projectionMatrix, Math.PI/4, aspect, 0.1, 1000.0);
            
            // è®¡ç®—è§†å›¾çŸ©é˜µ
            const viewMatrix = mat4.create();
            mat4.translate(viewMatrix, viewMatrix, [0, 0, -camera.z]);
            mat4.rotateX(viewMatrix, viewMatrix, camera.rx);
            mat4.rotateY(viewMatrix, viewMatrix, camera.ry);
            mat4.translate(viewMatrix, viewMatrix, [camera.x, camera.y, 0]);
            
            // æ¨¡å‹çŸ©é˜µï¼ˆå•ä½çŸ©é˜µï¼‰
            const modelMatrix = mat4.create();
            
            // æ¨¡å‹è§†å›¾çŸ©é˜µ
            const modelViewMatrix = mat4.create();
            mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
            
            // æ³•çº¿çŸ©é˜µ
            const normalMatrix = mat3.create();
            mat3.normalFromMat4(normalMatrix, modelViewMatrix);
            
            // è®¾ç½®uniforms
            gl.uniformMatrix4fv(terrainShader.uniforms.modelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(terrainShader.uniforms.projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix3fv(terrainShader.uniforms.normalMatrix, false, normalMatrix);
            
            // è®¾ç½®å…‰ç…§
            gl.uniform3f(terrainShader.uniforms.lightPosition, 10.0, 20.0, 10.0);
            gl.uniform3f(terrainShader.uniforms.lightColor, 1.0, 1.0, 1.0);
            gl.uniform3f(terrainShader.uniforms.viewPosition, camera.x, camera.y, camera.z);
            
            // ç»‘å®šé¡¶ç‚¹æ•°æ®
            gl.bindBuffer(gl.ARRAY_BUFFER, terrain.buffers.vertexBuffer);
            gl.vertexAttribPointer(terrainShader.attributes.position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(terrainShader.attributes.position);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, terrain.buffers.normalBuffer);
            gl.vertexAttribPointer(terrainShader.attributes.normal, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(terrainShader.attributes.normal);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, terrain.buffers.colorBuffer);
            gl.vertexAttribPointer(terrainShader.attributes.color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(terrainShader.attributes.color);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrain.buffers.indexBuffer);
            
            // çº¿æ¡†æ¨¡å¼
            if (currentWireframe) {
                gl.polygonOffset(1, 1);
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.uniform3f(terrainShader.uniforms.lightColor, 0.3, 0.3, 0.3);
            } else {
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
            
            // ç»˜åˆ¶ä¸‰è§’å½¢
            gl.drawElements(gl.TRIANGLES, terrain.buffers.indexCount, gl.UNSIGNED_SHORT, 0);
            
            // ç»˜åˆ¶çº¿æ¡†
            if (currentWireframe) {
                gl.enable(gl.POLYGON_OFFSET_LINE);
                gl.polygonOffset(-1, -1);
                gl.uniform3f(terrainShader.uniforms.lightColor, 1.0, 1.0, 1.0);
                
                // åˆ‡æ¢ä¸ºçº¿æ¡†ç»˜åˆ¶
                gl.drawElements(gl.LINES, terrain.buffers.indexCount, gl.UNSIGNED_SHORT, 0);
                gl.disable(gl.POLYGON_OFFSET_LINE);
            }
            
            // æ›´æ–°ç›¸æœºä¿¡æ¯
            cameraPositionSpan.textContent = `(${camera.x.toFixed(1)}, ${camera.y.toFixed(1)}, ${camera.z.toFixed(1)})`;
            cameraRotationSpan.textContent = `(${(camera.rx * 180/Math.PI).toFixed(1)}Â°, ${(camera.ry * 180/Math.PI).toFixed(1)}Â°)`;
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // è®¡ç®—FPS
            frameCount++;
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                fpsCounter.textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // è‡ªåŠ¨æ—‹è½¬
            if (currentAutoRotate) {
                camera.ry += 0.01;
            }
            
            render();
        }
        
        // å·¥å…·å‡½æ•°
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            random() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }
        
        class PerlinNoise {
            constructor(random) {
                this.p = new Array(512);
                this.permutation = new Array(256);
                
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(random.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                
                for (let i = 0; i < 512; i++) {
                    this.p[i] = this.permutation[i % 256];
                }
            }
            
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                
                const A = this.p[X] + Y;
                const AA = this.p[A] + Z;
                const AB = this.p[A+1] + Z;
                const B = this.p[X+1] + Y;
                const BA = this.p[B] + Z;
                const BB = this.p[B+1] + Z;
                
                return this.lerp(
                    this.lerp(
                        this.lerp(this.grad(this.p[AA], x, y, z), 
                        this.grad(this.p[BA], x-1, y, z), u),
                        this.lerp(this.grad(this.p[AB], x, y-1, z), 
                        this.grad(this.p[BB], x-1, y-1, z), u), v),
                    this.lerp(
                        this.lerp(this.grad(this.p[AA+1], x, y, z-1), 
                        this.grad(this.p[BA+1], x-1, y, z-1), u),
                        this.lerp(this.grad(this.p[AB+1], x, y-1, z-1), 
                        this.grad(this.p[BB+1], x-1, y-1, z-1), u), v), w
                );
            }
        }
        
        class SimplexNoise {
            constructor(random) {
                this.grad3 = [
                    [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
                    [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
                    [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
                ];
                this.p = new Array(512);
                this.permutation = new Array(256);
                
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(random.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                
                for (let i = 0; i < 512; i++) {
                    this.p[i] = this.permutation[i % 256];
                }
            }
            
            dot(g, x, y) {
                return g[0]*x + g[1]*y;
            }
            
            noise(xin, yin) {
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                
                let s = (xin + yin) * F2;
                let i = Math.floor(xin + s);
                let j = Math.floor(yin + s);
                
                let t = (i + j) * G2;
                let X0 = i - t;
                let Y0 = j - t;
                let x0 = xin - X0;
                let y0 = yin - Y0;
                
                let i1, j1;
                if (x0 > y0) {
                    i1 = 1; j1 = 0;
                } else {
                    i1 = 0; j1 = 1;
                }
                
                let x1 = x0 - i1 + G2;
                let y1 = y0 - j1 + G2;
                let x2 = x0 - 1.0 + 2.0 * G2;
                let y2 = y0 - 1.0 + 2.0 * G2;
                
                let ii = i & 255;
                let jj = j & 255;
                
                let gi0 = this.p[ii + this.p[jj]] % 12;
                let gi1 = this.p[ii + i1 + this.p[jj + j1]] % 12;
                let gi2 = this.p[ii + 1 + this.p[jj + 1]] % 12;
                
                let t0 = 0.5 - x0*x0 - y0*y0;
                let n0 = 0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                
                let t1 = 0.5 - x1*x1 - y1*y1;
                let n1 = 0;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                
                let t2 = 0.5 - x2*x2 - y2*y2;
                let n2 = 0;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                
                return 70.0 * (n0 + n1 + n2);
            }
        }
        
        // ç®€åŒ–çš„çŸ©é˜µæ•°å­¦åº“
        const mat4 = {
            create: function() {
                return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            },
            
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
                return out;
            },
            
            translate: function(out, a, v) {
                if (a !== out) {
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                }
                
                out[12] = a[0] * v[0] + a[4] * v[1] + a[8] * v[2] + a[12];
                out[13] = a[1] * v[0] + a[5] * v[1] + a[9] * v[2] + a[13];
                out[14] = a[2] * v[0] + a[6] * v[1] + a[10] * v[2] + a[14];
                out[15] = a[3] * v[0] + a[7] * v[1] + a[11] * v[2] + a[15];
                return out;
            },
            
            rotateX: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                
                if (a !== out) {
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                return out;
            },
            
            rotateY: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0];
                const a01 = a[1];
                const a02 = a[2];
                const a03 = a[3];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                
                if (a !== out) {
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                return out;
            },
            
            multiply: function(out, a, b) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                
                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                
                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                
                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                return out;
            },
            
            copy: function(out, a) {
                for (let i = 0; i < 16; i++) {
                    out[i] = a[i];
                }
                return out;
            }
        };
        
        const mat3 = {
            create: function() {
                return [1,0,0, 0,1,0, 0,0,1];
            },
            
            normalFromMat4: function(out, a) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                
                const det = b00 * b05 - b01 * b04 + b02 * b03;
                
                if (!det) {
                    out[0] = 1; out[1] = 0; out[2] = 0;
                    out[3] = 0; out[4] = 1; out[5] = 0;
                    out[6] = 0; out[7] = 0; out[8] = 1;
                    return out;
                }
                
                const invDet = 1.0 / det;
                
                out[0] = (a11 * b05 - a12 * b04 + a13 * b03) * invDet;
                out[1] = (a12 * b02 - a10 * b05 - a13 * b01) * invDet;
                out[2] = (a10 * b04 - a11 * b02 + a13 * b00) * invDet;
                out[3] = (a02 * b04 - a01 * b05 - a03 * b03) * invDet;
                out[4] = (a00 * b05 - a02 * b02 + a03 * b01) * invDet;
                out[5] = (a01 * b02 - a00 * b04 - a03 * b00) * invDet;
                out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
                out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * invDet;
                out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
                
                return out;
            }
        };
        
        // æ·»åŠ ç®€å•çš„çº¿æ¡†ç»˜åˆ¶æ”¯æŒ
        if (gl && !gl.LINES) {
            gl.LINES = 0x0001;
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('load', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–WebGL...');
            initWebGL();
        });
        
    </script>
</body>
</html>