<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>柏林噪声地形地图生成</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 20px;
        }
        canvas {
            border: 2px solid #333;
            background-color: #fff;
        }
        .controls {
            margin-bottom: 10px;
        }
        button {
            padding: 8px 16px;
            cursor: pointer;
            margin: 0 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="generateMap()">重新生成地图</button>
        <button onclick="zoomIn()">放大</button>
        <button onclick="zoomOut()">缩小</button>
    </div>
    <canvas id="mapCanvas" width="800" height="600"></canvas>

    <script>
        // 柏林噪声核心实现
        class PerlinNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.permutation = this.createPermutation();
            }

            // 创建置换表（用于梯度向量的随机选取）
            createPermutation() {
                const base = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
                    140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234,
                    75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
                    56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
                    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
                    245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,
                    89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186,
                    3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207,
                    206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152,
                    2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
                    108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242,
                    193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
                    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
                    150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66,
                    215, 61, 156, 180];
                // 加入种子打乱顺序（修复：使用seed作为随机数种子，确保每次打乱不同）
                const shuffled = [...base].sort(() => (Math.random() - 0.5) * this.seed);
                return [...shuffled, ...shuffled]; // 扩展为2倍长度，避免越界
            }

            // 计算点积
            dotProduct(grad, x, y) {
                switch (grad & 0x3) {
                    case 0x0: return x + y;
                    case 0x1: return -x + y;
                    case 0x2: return x - y;
                    case 0x3: return -x - y;
                    default: return 0;
                }
            }

            // 平滑插值函数（fade曲线）
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            // 线性插值
            lerp(a, b, t) {
                return a + t * (b - a);
            }

            // 获取噪声值（2D）
            getNoise(x, y) {
                const X = Math.floor(x) & 0xff;
                const Y = Math.floor(y) & 0xff;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const A = this.permutation[X] + Y;
                const B = this.permutation[X + 1] + Y;

                const topLeft = this.dotProduct(this.permutation[A], x, y);
                const topRight = this.dotProduct(this.permutation[B], x - 1, y);
                const bottomLeft = this.dotProduct(this.permutation[A + 1], x, y - 1);
                const bottomRight = this.dotProduct(this.permutation[B + 1], x - 1, y - 1);

                const lerp1 = this.lerp(topLeft, topRight, u);
                const lerp2 = this.lerp(bottomLeft, bottomRight, u);
                return this.lerp(lerp1, lerp2, v);
            }

            // 多倍频噪声（叠加多个octave增强细节）
            getFractalNoise(x, y, octaves = 4, persistence = 0.5, lacunarity = 2.0) {
                let total = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.getNoise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                return total / maxValue;
            }
        }

        // 地图生成与渲染
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        let noise; // 先声明，不初始化
        let scale = 0.01; // 噪声缩放比例（越小地图越平滑，越大细节越多）
        const octaves = 6; // 倍频数

        // 地形颜色映射（根据噪声值对应不同地形）
        function getTerrainColor(value) {
            if (value < 0.2) return '#1a5276'; // 深海
            if (value < 0.3) return '#2980b9'; // 浅海
            if (value < 0.4) return '#f4d03f'; // 沙滩
            if (value < 0.55) return '#229954'; // 平原/草地
            if (value < 0.7) return '#196f3d'; // 森林
            if (value < 0.85) return '#7f8c8d'; // 山地
            return '#ecf0f1'; // 雪山
        }

        // 生成并绘制地图（核心修复：每次生成新的噪声实例）
        function generateMap() {
            // 修复关键：每次生成新的PerlinNoise实例，使用随机种子
            noise = new PerlinNoise(Math.random() * 1000);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    // 获取多倍频柏林噪声值（范围[-1,1]，映射到[0,1]）
                    const noiseValue = (noise.getFractalNoise(x * scale, y * scale, octaves) + 1) / 2;
                    const color = hexToRgb(getTerrainColor(noiseValue));

                    const index = (y * canvas.width + x) * 4;
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                    data[index + 3] = 255; // 不透明度
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // 十六进制颜色转RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        // 缩放控制
        function zoomIn() {
            scale *= 1.2;
            generateMap(); // 缩放后重新生成（用新种子）
        }

        function zoomOut() {
            scale /= 1.2;
            generateMap(); // 缩放后重新生成（用新种子）
        }

        // 初始化地图（首次创建噪声实例）
        generateMap();
    </script>
</body>
</html>